//GFG: Maximum AND Value
//Description: Given an array arr[] of N positive elements. The task is to find the Maximum AND Value generated by any pair(arri, arrj) from the array such that i != j.
//Note: AND is bitwise '&' operator.

// Approach: Make a choice & check.
// Integer: 32 Bits
// For every bit position starting from the MSB, set the bit and check whether it can be attained by performing AND operation among the ARRAY elements.
// Now, if the bit can be attained i.e. AND of two or more elements gives the set bit at the pattern position (MSB): The bit remains set, otherwise as it is not possible reset the bit to zero.
// Repeat the process for every bit position, given that the AND of element follows the pattern of 1's and 0's previously attained.

#include<bits/stdc++.h>
using namespace std;

class Solution{
public:
    int maxAND (int A[], int N){
        bitset<32> bset(0);
        
        for(int i=31; i>=0; i--){
            bset[i] = 1;
            int counter = 0;
            
            int value = bset.to_ulong();    //Convert bitset into decimal.
            for(int i=0; i<N; i++){
                if((A[i] & value) == value) counter += 1;   //Check for repeating pattern in two or more integers.
            }
            
            if(counter < 2) bset[i] = 0;    //If current pattern not found: The bit cannot be set.
        }
        
        return int(bset.to_ulong());
    }
};

int main(){
    Solution solve;
    
    return 0;
}